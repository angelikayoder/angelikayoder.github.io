<!DOCTYPE html>
<html>

<head>
  <title>Angelika Yoder's blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
</head>

<body>
   <header>
      <h1 id="my-title">Angelika Yoder's Blog</h1>
       <img id="profile" src="../imgs/profilepic.jpg">

       <aside>
       <a href="https://twitter.com/angelikayoder"><img src="../imgs/icon-twitterLogo.png"></a>
       <a href="https://www.facebook.com/angelika.yoder/about"><img src="../imgs/facebookIcon.png"></a>
       <a href="https://www.linkedin.com/in/angelika-yoder-394270109"><img src="../imgs/linkedin.png"></a>
       <a href="https://github.com/angelikayoder"><img src="../imgs/Octocat.png"></a>
     </aside>
     <nav>
       <a href="http://angelikayoder.github.io/">Website</a>  |
       <a href="http://angelikayoder.github.io/about-me">About Me</a>  |
       <a href="http://angelikayoder.github.io/blog/">Blog</a>  |
       <a href="http://angelikayoder.github.io/contact"/>Contact</a>
     </nav>

   </header>

 </header>



  <article>
  <h2>Test-driven Development</h2>
  <p>Test-driven development (TDD) is a software development process that relies
     on the repetition of a very short development cycle: first the developer writes
      an (initially failing) automated test case that defines a desired improvement
      or new function, then produces the minimum amount of code to pass that test,
      and finally refactors the new code to acceptable standards. Kent Beck, who is
      credited with having developed or 'rediscovered'the technique, stated in 2003
      that TDD encourages simple designs and inspires confidence.</p>

<p>Test-driven development is related to the test-first programming concepts of
  extreme programming, begun in 1999 but more recently has created more general
  interest in its own right. Programmers also apply the concept to improving and
  debugging legacy code developed with older techniques.</p>

  <h4>Test-driven development cycle</h4>

<ol>

<li>Add a test</li>
<p>In test-driven development, each new feature begins with writing a test. To
  write a test, the developer must clearly understand the feature's specification
  and requirements. The developer can accomplish this through use cases and user
  stories to cover the requirements and exception conditions, and can write the test
  in whatever testing framework is appropriate to the software environment. It could
  be a modified version of an existing test. This is a differentiating feature of
  test-driven development versus writing unit tests after the code is written:
  it makes the developer focus on the requirements before writing the code, a
  subtle but important difference.</p>

<li>Run all tests and see if the new one fails</li>
<p>This validates that the test harness is working correctly, that the new test
  does not mistakenly pass without requiring any new code, and that the required
  feature does not already exist. This step also tests the test itself, in the
  negative: it rules out the possibility that the new test always passes, and
  therefore is worthless. The new test should also fail for the expected reason.
  This step increases the developer's confidence that the unit test is testing the
  correct constraint, and passes only in intended cases.</p>

<li>Write some code</li>
<p>The next step is to write some code that causes the test to pass. The new
  code written at this stage is not perfect and may, for example, pass the test
  in an inelegant way. That is acceptable because it will be improved and honed
  in Step 5.At this point, the only purpose of the written code is to pass the
  test; no further (and therefore untested) functionality should be predicted
  nor 'allowed for' at any stage.</p>

<li>Run tests</li>
<p>If all test cases now pass, the programmer can be confident that the new code
  meets the test requirements, and does not break or degrade any existing features.
  If they do not, the new code must be adjusted until they do.</p>

<li> Refactor code</li>
<p>The growing code base must be cleaned up regularly during test-driven development.
  New code can be moved from where it was convenient for passing a test to where
  it more logically belongs. Duplication must be removed. Object, class, module,
  variable and method names should clearly represent their current purpose and use,
  as extra functionality is added. As features are added, method bodies can get
  longer and other objects larger. They benefit from being split and their parts
  carefully named to improve readability and maintainability, which will be
  increasingly valuable later in the software lifecycle. Inheritance hierarchies
  may be rearranged to be more logical and helpful, and perhaps to benefit from
  recognised design patterns. There are specific and general guidelines for
  refactoring and for creating clean code. By continually re-running the
  test cases throughout each refactoring phase, the developer can be confident
  that process is not altering any existing functionality.The concept of removing
  duplication is an important aspect of any software design. In this case,
  however, it also applies to the removal of any duplication between the test
  code and the production code—for example magic numbers or strings repeated in
  both to make the test pass in Step 3.</p>

  <h4>Benefits</h4>
  <p>A 2005 study found that using TDD meant writing more tests and, in turn,
    programmers who wrote more tests tended to be more productive. Hypotheses
    relating to code quality and a more direct correlation between TDD and
    productivity were inconclusive.Programmers using pure TDD on new projects
    reported they only rarely felt the need to invoke a debugger. Used in conjunction
    with a version control system, when tests fail unexpectedly, reverting the
    code to the last version that passed all tests may often be more productive
    than debugging.
    <br>
    Test-driven development offers more than just simple validation
    of correctness, but can also drive the design of a program. By focusing on
    the test cases first, one must imagine how the functionality is used by
    clients (in the first case, the test cases). So, the programmer is concerned
    with the interface before the implementation. This benefit is complementary
    to Design by Contract as it approaches code through test cases rather than
    through mathematical assertions or preconceptions. Test-driven development
    offers the ability to take small steps when required. It allows a programmer
    to focus on the task at hand as the first goal is to make the test pass.
    Exceptional cases and error handling are not considered initially, and tests
    to create these extraneous circumstances are implemented separately. Test-driven
    development ensures in this way that all written code is covered by at least
    one test. This gives the programming team, and subsequent users, a greater
    level of confidence in the code.
    <br>
    While it is true that more code is required with TDD than without TDD because
    of the unit test code, the total code implementation time could be shorter
    based on a model by Müller and Padberg. Large numbers of tests help to limit
    the number of defects in the code. The early and frequent nature of the testing
    helps to catch defects early in the development cycle, preventing them from
    becoming endemic and expensive problems. Eliminating defects early in the
    process usually avoids lengthy and tedious debugging later in the project.
    TDD can lead to more modularized, flexible, and extensible code. This effect
    often comes about because the methodology requires that the developers think
    of the software in terms of small units that can be written and tested independently
    and integrated together later. This leads to smaller, more focused classes,
    looser coupling, and cleaner interfaces. The use of the mock object design
    pattern also contributes to the overall modularization of the code because
    this pattern requires that the code be written so that modules can be switched
    easily between mock versions for unit testing and "real" versions for deployment.
    Because no more code is written than necessary to pass a failing test case,
    automated tests tend to cover every code path. For example, for a TDD developer
    to add an else branch to an existing if statement, the developer would first have
    to write a failing test case that motivates the branch. As a result, the
    automated tests resulting from TDD tend to be very thorough: they detect any
    unexpected changes in the code's behaviour. This detects problems that can
    arise where a change later in the development cycle unexpectedly alters other
    functionality.</p>
    <br>
    <h4>Limitations</h4>
    <p>Test-driven development does not perform sufficient testing in situations
      where full functional tests are required to determine success or failure,
      due to extensive use of unit tests.Examples of these are user interfaces,
      programs that work with databases, and some that depend on specific network
      configurations. TDD encourages developers to put the minimum amount of code
      into such modules and to maximize the logic that is in testable library code,
      using fakes and mocks to represent the outside world.
      Management support is essential. Without the entire organization believing
      that test-driven development is going to improve the product, management
      may feel that time spent writing tests is wasted. Unit tests created in a
      test-driven development environment are typically created by the developer
      who is writing the code being tested. Therefore, the tests may share blind
      spots with the code: if, for example, a developer does not realize that certain
      input parameters must be checked, most likely neither the test nor the code
      will verify those parameters. Another example: if the developer misinterprets
      the requirements for the module he is developing, the code and the unit tests
      he writes will both be wrong in the same way. Therefore, the tests will pass,
      giving a false sense of correctness.
      <br>
      A high number of passing unit tests may bring a false sense of security,
      resulting in fewer additional software testing activities, such as integration
      testing and compliance testing.
      <br>
      Tests become part of the maintenance overhead of a project. Badly written
      tests, for example ones that include hard-coded error strings or are themselves
      prone to failure, are expensive to maintain. This is especially the case with
      fragile tests. There is a risk that tests that regularly generate false failures
      will be ignored, so that when a real failure occurs, it may not be detected.
      It is possible to write tests for low and easy maintenance, for example by t
      he reuse of error strings, and this should be a goal during the code
      refactoring phase described above. Writing and maintaining an excessive number of
      tests costs time. Also, more-flexible modules (with limited tests) might
      accept new requirements without the need for changing the tests. For those
      reasons, testing for only extreme conditions, or a small sample of data,
      can be easier to adjust than a set of highly detailed tests. However,
      developers could be warned about overtesting to avoid the excessive work,
      but it might require advanced skills in sampling or factor analysis.
      <br>
      The level of coverage and testing detail achieved during repeated TDD
      cycles cannot easily be re-created at a later date. Therefore these original,
      or early, tests become increasingly precious as time goes by. The tactic is
      to fix it early. Also, if a poor architecture, a poor design, or a poor testing
      strategy leads to a late change that makes dozens of existing tests fail, then
      it is important that they are individually fixed. Merely deleting, disabling
      or rashly altering them can lead to undetectable holes in the test coverage.</p>
</article>

<a href="#">Older Posts</a>


 <footer>
   <p><a href="#">Legal</a></p>
 </footer>


 </body>

</html>
